# Load necessary libraries
library(ggplot2)
library(dplyr)
library(boot)
library(DEP)
library(tidyverse)

# Load the data
protein_data <- read.delim("/Users/hzha0252/Documents/5. DIA-Analyst/Solvent profilling/data/20240215_124144_SPP-ONE-POT-GS_Report.tsv", check.names = F)
# exp_design <- read_csv("/Users/hzha0252/Documents/5. DIA-Analyst/Solvent profilling/data/Lysate-exp1-one-pot_exptDesign.csv")
exp_design <- read_csv("/Users/hzha0252/Documents/5. DIA-Analyst/Solvent profilling/data/exptDesign_with_condition&replicates.csv")


# id_col - "PG.ProteinGroups" 
# intensity_cols - endwith("PG.Quantity)
# selected_protein <- "transcript=PF3D7_0513300.1"
selected_protein <- "transcript=PF3D7_1476500.1"

data <- protein_data[protein_data$PG.ProteinGroups == selected_protein, grep("PG.Quantity", names(protein_data))]
data <- t(data) %>% data.frame() %>% rownames_to_column()
names(data) <- c("label", "intensity")


data <- data %>% right_join(exp_design, by = c("label" = "column"))
data$treatment <- factor(data$treatment)
data$condition <- factor(data$condition)
names(data) = make.names(names(data))


# in seaborn line (from python)
# By default, the plot aggregates over multiple y values (intensity) at each value of x (solv%) and shows an estimate of 
# the central tendency and a confidence interval for that estimate.
# estimator='mean', errorbar=('ci', 95)
# Function to calculate the mean for bootstrapping
boot_mean <- function(data, indices) {
  return(mean(data[indices]))
}

# Function to perform bootstrapping and calculate CIs for each group
bootstrap_ci <- function(data, abundance, n_bootstrap = 1000) {
  results <- data %>%
    group_by(solv., treatment) %>%
    do({
      boot_result <- boot(.[[abundance]], statistic = boot_mean, R = n_bootstrap)
      ci <- boot.ci(boot_result, type = "perc")
      data.frame(
        mean_abundance = mean(.[[abundance]]),
        ci_lower = if(!is.null(ci)) ci$percent[4] else NA,
        ci_upper = if(!is.null(ci)) ci$percent[5] else NA
      )
    }) %>%
    ungroup()
  return(results)
}

# Calculate bootstrapped confidence intervals
boot_data <- bootstrap_ci(data, "intensity")

# Plot the data with shaded CI area
p <- ggplot(boot_data, aes(x = solv., y = mean_abundance, color = treatment, group = treatment)) +
  geom_line() +
  geom_point() +
  geom_ribbon(aes(ymin = ci_lower, ymax = ci_upper, fill = treatment), color = NA, alpha = 0.2) +
  geom_errorbar(aes(ymin = ci_lower, ymax = ci_upper), width = 0.2, alpha = 0.2) +
  labs(x = "Solv%", y = "Mean Abundance", title = "Mean Abundance by Solv% and Treatment with Bootstrapped CI") +
  theme_DEP1() +
  scale_color_manual(values = c("#2a7bb7", "#ff8626")) +
  scale_fill_manual(values = c("#2a7bb7", "#ff8626")) +
  theme(legend.position = "top")

p

# # draw for condition
# # Function to perform bootstrapping and calculate CIs for each group
# bootstrap_ci <- function(data, abundance, n_bootstrap = 1000) {
#   results <- data %>%
#     group_by(solv., condition) %>%
#     do({
#       boot_result <- boot(.[[abundance]], statistic = boot_mean, R = n_bootstrap)
#       ci <- boot.ci(boot_result, type = "perc")
#       data.frame(
#         mean_abundance = mean(.[[abundance]]),
#         ci_lower = if(!is.null(ci)) ci$percent[4] else 0,
#         ci_upper = if(!is.null(ci)) ci$percent[5] else 0
#       )
#     }) %>%
#     ungroup()
#   return(results)
# }
# 
# # Calculate bootstrapped confidence intervals
# boot_data <- bootstrap_ci(data, "intensity")
# 
# ggplot(boot_data, aes(x = solv., y = mean_abundance, color = condition, group = condition)) +
#   geom_line() +
#   geom_point() +
#   geom_ribbon(aes(ymin = ci_lower, ymax = ci_upper, fill = condition), color = NA, alpha = 0.2) +
#   geom_errorbar(aes(ymin = ci_lower, ymax = ci_upper), width = 0.2, alpha = 0.2) +
#   labs(x = "Solv%", y = "Mean Abundance", title = "Mean Abundance by Solv% and Treatment with Bootstrapped CI") +
#   theme_DEP1() +
#   scale_color_manual(values = c("#2a7bb7", "#ff8626")) +
#   scale_fill_manual(values = c("#2a7bb7", "#ff8626")) +
#   theme(legend.position = "top")


# individual calculation
sub_dmso_3 <- data %>% filter(treatment == "DMSO" & solv.==3)
boot_result <- boot(sub_dmso_3$abundance, statistic = boot_mean, R = 1000)
ci <- boot.ci(boot_result, type = "perc")
ci$percent
