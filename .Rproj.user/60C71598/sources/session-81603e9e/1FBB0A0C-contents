#### Absence/Presence tab ui ####

attendance_ui <- function(id){
  ns <- NS(id)
  tagList(
    br(),
    fluidRow(
      # tags$style(
      #   ".box {
      #   border-top: none;
      #   box-shadow: 0 0px 0px rgb(0 0 0 / 10%);
      #   }"
      # ),
      column(3,
             box(width =NULL,
                 title = "Options",
                 tags$p("Pre-filter Results table and Venn plot by the Sliders of each condition/group below, 
                                    and/or the Filter Condition"),
                 
                 # shinyWidgets::prettyRadioButtons(ns("intensity_type"),
                 #                                  "Choose Intensity type",
                 #                                  choices = c("LFQ intensity (Based on Razor peptide)" = "LFQ_intensity",
                 #                                              "Max LFQ intensity (Based on unique peptide)" = "MaxLFQ_intensity"),
                 #                                  selected = "LFQ_intensity",
                 #                                  status = "primary", 
                 #                                  shape = "square"
                 # ),
                 tags$hr(),
                 tags$h4("Number of replicates present"),
                 tags$style(type = "text/css", ".irs-grid-pol.small {height: 0px;}"), # hide minor ticks of a sliderInput
                 uiOutput(ns('sidebar')),
                 tags$hr(),
                 tags$h4(HTML("DIA Filter Condition<br/>Remove")),
                 shinyWidgets::prettyCheckbox(ns("filtered_condition_dia"),
                                              "Reverses and Contaminants",
                                              shape = "round"
                 ),
                 # shinyWidgets::prettyCheckboxGroup(ns("filtered_condition_fragpipe"),
                 #                                   HTML("Fragpipe Filter Condition<br/>Remove"),
                 #                                   choices = c('Proteins with peptides < 2'
                 #                                   ),
                 #                                   shape = "round",
                 #                                   selected = NULL,
                 #                                   status = "primary"
                 # ),
                 status = "success",
                 solidHeader = TRUE)
      ), # slider bar column closed
      column(9,
             box(width = NULL,
                 title = "Results Table",
                 shinycssloaders::withSpinner(DT::dataTableOutput(ns("contents_occ")),
                                              color = "#3c8dbc"),
                 downloadButton(ns('download_attendance'), 'Download Table'),
                 status = "success",
                 solidHeader = TRUE),
             tabBox(
               width = NULL,
               height = 620,
               tabPanel(
                 title = "Venn Plot",
                 tags$p('Select conditions/groups to generate the Venn plot. By default, more than three conditions/groups generates a 3D Venn plot, 
                         set last option as "NONE" to generate a 2D Venn plot'),
                 column(12,
                        box(width = 4,id = "con_1",uiOutput(ns("condition_1"))),
                        box(width = 4,id = "con_2", uiOutput(ns("condition_2"))),
                        box(width = 4,id = "con_3", uiOutput(ns("condition_3")))),
                 column(12,
                        shinycssloaders::withSpinner(plotOutput(ns("venn_plot")),
                                                     color = "#3c8dbc")
                 ),
                 downloadButton(ns('download_venn_svg'), "Save svg")
                 ),
               tabPanel(
                 title = "UpSet Plot",
                 shinycssloaders::withSpinner(plotOutput(ns("upset_plot"),width = "100%", height = 520), 
                                              color = "#bec8da"),
                 downloadButton(ns('download_upset_svg'), "Save svg")
               )
             )
             # box(width = NULL,
             #     title = "Venn Plot",
             #     tags$p('Select conditions/groups to generate the Venn plot. By default, more than three conditions/groups generates a 3D Venn plot,
             #                                set Condition 3 as "NONE" to generate a 2D Venn plot'),
             #     column(12,
             #            box(width = 4,id = "con_1",uiOutput(ns("condition_1"))),
             #            box(width = 4,id = "con_2", uiOutput(ns("condition_2"))),
             #            box(width = 4,id = "con_3", uiOutput(ns("condition_3")))),
             #     column(12,
             #            shinycssloaders::withSpinner(plotOutput(ns("venn_plot")),
             #                                         color = "#3c8dbc")
             #            ),
             #     column(12, downloadButton(ns('download_venn_svg'), "Save svg")),
             #     status = "success",
             #     solidHeader = TRUE)
      ) # Venn plot column closed
    ) # fuildRow close
  )
}



#### Absence/Presence tab server ####

#processed_data, imputed_data, normalised_data, dep
attendance_server <- function(id,dia_data_input,exp_design_input){
  moduleServer(
    id,
    function(input, output,session){
      ns <- session$ns
      
      #### Occurrence page logic ####
      data_attendance<-reactive({
        dia_data <- dia_data_input()
        
        #check dia columns
        if (any(grep("PG.Quantity", colnames(dia_data)))){ # output from spectronaut
          dia_columns<-grep("PG.Quantity", colnames(dia_data))
          # tidy column names
          colnames(dia_data)[dia_columns] <- colnames(dia_data)[dia_columns] %>% sub("^[^_]*_", "",.) %>% sub(".htrms","",.) %>% sub(".PG.Quantity","",.) %>% sub(".raw","",.)
        } else {
          dia_columns<- which(!(colnames(dia_data) %in% 
                                        c("Protein.Group", "Protein.Ids", "Protein.Names", "Genes", "First.Protein.Description", "name","ID")))
          # tidy column names
          colnames(dia_data)[dia_columns] <- colnames(dia_data)[dia_columns] %>% sub(".htrms","",.) %>% sub(".PG.Quantity","",.) %>% sub(".raw","",.)
        }
        
        # if included, replace "Filtered" with NA (some spectronaut's output)
        dia_data <- replace(dia_data, dia_data == "Filtered", NA) 
        
        # ensure all intensity columns are numeric type
        dia_data[,dia_columns] <- suppressWarnings(sapply(dia_data[,dia_columns],as.numeric))
        # replace NA to 0
        dia_data <- dia_data %>% dplyr::mutate_if(is.numeric,~tidyr::replace_na(.,0))
        
        # # tidy column names
        # colnames(dia_data)[dia_columns] <- colnames(dia_data)[dia_columns] %>% sub("^[^_]*_", "",.) %>% sub(".htrms","",.) %>% sub(".PG.Quantity","",.) %>% sub(".raw","",.)
        intensity_names <- colnames(dia_data)[dia_columns]
        
        needed_cols <- c("PG.Genes","PG.ProteinAccessions","Genes", "Protein.Group", intensity_names)
        
        df <- dia_data[,colnames(dia_data) %in% needed_cols]
        colnames(df)[grep( "Genes", names(df))] <- "Gene Names"
        colnames(df)[grep("Protein", names(df))] <- "Proten IDs"
        
        # get conditions
        exp_design <- exp_design_input()
        exp_design$label <- exp_design$label  %>% sub(".raw","",.)
        conditions <- exp_design$condition %>% unique()
        
        # replace intensity column names
        replace_protein <- paste("Intensity",exp_design$condition, exp_design$replicate,sep = "_") %>% unique()
        
        if (any(make.names(intensity_names) %in% make.names(exp_design$label))){
          colnames(df)[colnames(df) %in% intensity_names] <- replace_protein[match(make.names(intensity_names), 
                                                                                   make.names(exp_design$label), nomatch = NA)]
        } else {
          colnames(df)[colnames(df) %in% intensity_names] <- replace_protein[match(delete_prefix(make.names(intensity_names)), 
                                                                                   delete_prefix(make.names(exp_design$label)), nomatch = NA)]
        }
        
        # remove intensity columns not in experimental design file.
        df <- df[!is.na(names(df))]
        # filter if all intensity are 0
        df <- df[rowSums(df[,grep("^Intensity_", colnames(df))]) != 0,]
        
        for (i in 1:length(conditions)) {
          condition <- conditions[i]
          pattern <- paste("^Intensity",condition,"[[:digit:]]",sep = "_")
          df[paste0("#Occurences",sep = "_",condition)] <- rowSums(df %>% select(grep(pattern, colnames(df))) != 0)
          
          # change column order
          df <- dplyr::relocate(df, paste0("#Occurences",sep = "_",condition), .before = colnames(df)[grep("^Intensity",colnames(df))][1], .after = NULL)
          # print(colnames(df))
          cols <- grep(paste0(condition, "$"),colnames(df))
          
          if (!is.null(input[[paste0("",condition)]])){
            df <- df %>%
              dplyr::filter(df[[cols]] >=input[[paste0("",condition)]][1] & df[[cols]] <=input[[paste0("",condition)]][2])
          }
        }
        
        if ("" %in% df$Gene.names){
          df$Gene.names[df["Gene.names"]==""] <- "NoGeneNameAvailable"}
        return(df)
      })
      
      data_attendance_filtered <- reactive({
        filtered_data <- data_attendance()
        if (input$filtered_condition_dia){
          # filtered out contaminant and reverse proteins
          if (any(grepl("^CON__|^Cont_|^REV__|^REFSEQ",filtered_data$`Proten IDs`))){
            filtered_data <- filtered_data %>% dplyr::filter(!grepl("^CON__|^Cont_|^REV__|^REFSEQ", `Proten IDs`))
          } else {
            filtered_data <- filtered_data
          }
        }
        return(filtered_data)
      })
      
      #### Data table
      output$contents_occ <- DT::renderDataTable({
        df<- data_attendance_filtered()
        return(df)},
        options = list(scrollX = TRUE,
                       scroller = TRUE,
                       autoWidth=TRUE,
                       columnDefs = list(
                         list(targets = 2,
                              render = JS(
                                "function(data, type, row, meta) {",
                                "return type === 'display' && data.length > 15 ?",
                                "'<span title=\"' + data + '\">' + data.substr(0, 15) + '...</span>' : data;",
                                "}")
                         ),
                         list(targets = 1,
                              render = JS(
                                "function(data, type, row, meta) {",
                                "return type === 'display' && data.length > 30 ?",
                                "'<span title=\"' + data + '\">' + data.substr(0, 30) + '...</span>' : data;",
                                "}")
                         )
                       )
        )
      )
      
      make_sliderInput <- function(n= 1){
        conditions <- exp_design_input()$condition %>% unique()
        individuals <- subset(exp_design_input(), condition == conditions[n])
        sliderInput(paste0("",ns(conditions[n])),
                    label=paste0("",conditions[n]),
                    min = min(0), 
                    max = nrow(individuals),
                    value = c(0, nrow(individuals)),
                    step = 1)}
      
      slider_bars <- reactive({
        exp_design <- exp_design_input()
        lapply(X = 1:length(unique(exp_design$condition)), FUN = make_sliderInput)
      })
      
      output$sidebar <- renderUI({
        tagList(slider_bars())
      })
      
      output$download_attendance <- downloadHandler("Occurrences_results_table.csv",
                                                    content = function(file){
                                                      write.table(data_attendance_filtered(),  
                                                                  file,
                                                                  col.names = TRUE,
                                                                  row.names = FALSE,
                                                                  sep =",")
                                                    },
                                                    contentType = "text/csv")
      
      ## Venn plot
      condition_list <- reactive({
        if(!is.null(exp_design_input())){
          exp_design <- exp_design_input()
          conditions <- exp_design$condition %>% unique() %>% sort()
          return(conditions)
        }
      })
      
      observeEvent(input$analyze, {
        if (length(condition_list()) == 1){
          shinyjs::hide(id = "con_2")
          shinyjs::hide(id = "con_3")
        } 
        if (length(condition_list()) == 2){
          shinyjs::hide(id = "con_3")
        } 
      })
      
      output$condition_1 <- renderUI({
        if (!is.null(condition_list())){
          selectizeInput(ns("condition_1"),
                         NULL,
                         choices = condition_list(),
                         selected = condition_list()[1])
        }
      })
      
      output$condition_2 <- renderUI({
        if (!is.null(condition_list()) & length(condition_list()) > 1){
          selectizeInput(ns("condition_2"),
                         NULL,
                         # choices = condition_list(),
                         choices = condition_list()[condition_list() != input$condition_1],
                         selected = condition_list()[2])
        }
      })
      
      output$condition_3 <- renderUI({
        if (!is.null(condition_list())  & length(condition_list()) > 2){
          selectizeInput(ns("condition_3"),
                         NULL,
                         # choices = condition_list(),
                         choices = c("NONE", condition_list()[condition_list() != input$condition_1 & condition_list() != input$condition_2]),
                         selected = condition_list()[3])
        }
      })
      
      venn_plot_input <- reactive({
        df<- data_attendance_filtered()
        if(length(condition_list()) < 2){
          stop(safeError("Venn plot should contain at least two sets"))
        } else if(length(condition_list()) < 3){
          set1 <- df$`Proten IDs`[df[grep(paste0("#Occurences",sep = "_",input$condition_1),colnames(df))] != 0]
          set2 <- df$`Proten IDs`[df[grep(paste0("#Occurences",sep = "_",input$condition_2),colnames(df))] != 0]
          x <- list(set1,set2)
          names(x) <- c(input$condition_1, input$condition_2)
        } else {
          set1 <- df$`Proten IDs`[df[grep(paste0("#Occurences",sep = "_",input$condition_1),colnames(df))] != 0]
          set2 <- df$`Proten IDs`[df[grep(paste0("#Occurences",sep = "_",input$condition_2),colnames(df))] != 0]
          set3 <- df$`Proten IDs`[df[grep(paste0("#Occurences",sep = "_",input$condition_3),colnames(df))] != 0]
          x <- list(set1,set2,set3)
          names(x) <- c(input$condition_1, input$condition_2, input$condition_3)
          if (!is.null(input$condition_3)){
            if (input$condition_3 == "NONE"){
              x <- list(set1,set2)
              names(x) <- c(input$condition_1, input$condition_2)
            }
          }
        }
        ggVennDiagram::ggVennDiagram(x,label_alpha = 0) +
          scale_x_continuous(expand = expansion(mult = .2)) +  # avoid group names be cropped if too long
          scale_fill_gradient(low = "#F4FAFE", high = "#4981BF")
      })
      
      output$venn_plot <- renderPlot({
        if (!is.null(input$condition_1) & !is.null(input$condition_2)){
          venn_plot_input()
        }
      })
      
      output$download_venn_svg<-downloadHandler(
        filename = function() { "venn_plot.svg" }, 
        content = function(file) {
          svg(file)
          print(venn_plot_input())
          dev.off()
        }
      )
      
      ## UpSet plot
      upset_plot_input <- reactive({
        df <- data_attendance_filtered()
        df <- df[,grep("#Occurences", colnames(df))]
        # change occurences to binary value
        df <- ifelse(df != 0, 1,0)
        
        df <- data.frame(df)
        colnames(df) <- colnames(df) %>% gsub("X.Occurences_","",.)
        
        if (sum(colSums(df) != 0) > 1){ # avoid error if only has one dimension for the UpSet plot
          UpSetR::upset(df,nsets = ncol(df),
                        mb.ratio = c(0.6, 0.4),
                        text.scale = 1.5,
                        point.size = 3,
                        order.by = "freq",
                        decreasing = T,
                        nintersects = NA,
                        mainbar.y.label = "#Proteins in intersection",
                        sets.x.label = "#Proteins",
                        set_size.scale_max = round(nrow(df) * 1.2), #TODO: find another way to avoid cropping of set_size number
                        # set_size.angles = 45, 
                        set_size.show = T
          )
        } else {
          ggplot() +
            annotate("text", x = 1,  y = 1,
                     size = 7,
                     label = "UpSet Plot could not be performed.\nAt least two conditions/groups are required") + 
            theme_void()
        }
      })
      
      output$upset_plot <- renderPlot({
        upset_plot_input()
      })
      
      output$download_upset_svg<-downloadHandler(
        filename = function() { "upset_plot.svg" }, 
        content = function(file) {
          svg(file)
          print(upset_plot_input())
          dev.off()
        }
      )
      # return(data_attendance)
    }
  )
}